"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toDiffCompatibleJsonSchemaMap = exports.toDiffCompatibleJsonSchema = void 0;
const toDiffCompatibleJsonSchemaArray = (schemaArray) => schemaArray.map((schemaEntry) => exports.toDiffCompatibleJsonSchema(schemaEntry));
const toDiffCompatibleJsonSchemaOrArray = (schemaOrArray) => {
    return Array.isArray(schemaOrArray)
        ? toDiffCompatibleJsonSchemaArray(schemaOrArray)
        : exports.toDiffCompatibleJsonSchema(schemaOrArray);
};
const toDiffCompatibleAdditionalProperties = (schema) => {
    return typeof schema === 'boolean'
        ? schema
        : exports.toDiffCompatibleJsonSchema(schema);
};
const toDiffCompatibleNumberBoundary = (exclusive, boundary) => {
    return exclusive ? boundary : undefined;
};
// tslint:disable:cyclomatic-complexity
const toDiffCompatibleJsonSchemaProperties = (schema, propertyName) => {
    const schemaProperty = schema[propertyName];
    switch (propertyName) {
        case 'exclusiveMaximum':
            return toDiffCompatibleNumberBoundary(schemaProperty, schema.maximum);
        case 'exclusiveMinimum':
            return toDiffCompatibleNumberBoundary(schemaProperty, schema.minimum);
        case 'items':
            return toDiffCompatibleJsonSchemaOrArray(schemaProperty);
        case 'additionalProperties':
            return toDiffCompatibleAdditionalProperties(schemaProperty);
        case 'not':
            return exports.toDiffCompatibleJsonSchema(schemaProperty);
        case 'properties':
            return exports.toDiffCompatibleJsonSchemaMap(schemaProperty);
        case 'allOf':
        case 'anyOf':
        case 'oneOf':
            return toDiffCompatibleJsonSchemaArray(schemaProperty);
        default:
            return schemaProperty;
    }
};
exports.toDiffCompatibleJsonSchema = (schema) => {
    const compatibleJsonSchema = {};
    for (const propertyName of Object.keys(schema)) {
        compatibleJsonSchema[propertyName] = toDiffCompatibleJsonSchemaProperties(schema, propertyName);
    }
    return compatibleJsonSchema;
};
exports.toDiffCompatibleJsonSchemaMap = (schemaMap) => {
    const compatibleJsonSchemaMap = {};
    for (const propertyName of Object.keys(schemaMap)) {
        compatibleJsonSchemaMap[propertyName] = exports.toDiffCompatibleJsonSchema(schemaMap[propertyName]);
    }
    return compatibleJsonSchemaMap;
};
